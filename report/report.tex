\documentclass{article}

% Use packages for additional functionality
\usepackage{titlesec}   % Customize section titles
\usepackage{lipsum}      % Generate placeholder text
\usepackage{biblatex}    % Handle bibliography
\usepackage[skins,minted]{tcolorbox}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage[left=3.3cm, right=3cm, top=3.3cm, bottom=3cm]{geometry}
\hyphenation{exam-ple}

\setminted{fontsize=\footnotesize}
% Title and Author Information
\title{Security in Software Application Assignment}
\author{Owanesh}
\date{Jan 2024}

% Define Section and Subsection Formatting
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}[:]

\begin{document}

% Create Title
\maketitle

% Abstract
\begin{abstract}
    This report will analyze the security of a provided Taxpayer.sol 
    contract. Security will be analyzed and tested through the use of 
    the Echidna tool. To make the code more robust throughout the report 
    only \mintinline{solidity}{require()} functions will be used to 
    increase backward compatibility. Where there are lines of code with 
    the exception of \mintinline{solidity}{require()}, this will be 
    explained by demonstrating its usefulness based on the assumptions made.

    This report is part of the Security in Software Application course at La Sapienza University of Rome. It is therefore not intended as a scientific research paper, but as a report for laboratory exercise.
\end{abstract}

% Table of Contents
\tableofcontents

% Sections
\section{Introduction to fuzz testing}
Fuzz testing is a dynamic testing technique used to discover coding 
errors and security loopholes in software, by inputting massive amounts 
of random data, called fuzz, to the system in an attempt to make it crash. 
This technique is especially effective in finding vulnerabilities in 
software applications, including smart contracts like in this report.

In the context of smart contracts, other popular tool for 
fuzz testing is Malticore and Foundry. Echidna is an Haskell\footnote{Haskell is a functional programming language} program designed 
for fuzzing/property-based testing of Ethereum smart contracts. 
It uses sophisticated grammar-based fuzzing campaigns based 
on a contract ABI\footnote{A contract ABI, or Application Binary Interface, in the context of Ethereum, is essentially a specification for how to interact with a contract on the Ethereum blockchain} to falsify user-defined predicates or Solidity assertions.
Instead of other softwares, Echidna includes also other tools like slither.

One of the key features of Echidna is its unique 'property-based fuzzing',
 which tries to falsify user-defined invariants (properties) 
 instead of looking for crashes like a traditional fuzzer. 
 This makes it particularly effective at finding subtle vulnerabilities that might not be caught by other types of testing.

This report focuses on the application of fuzz testing to 
the Taxpayer.sol contract, a smart contract in the Ethereum blockchain. 
The contract includes several \texttt{require()}\footnote{The require() function in Solidity is used for input validation and conditional checking. It throws an exception and terminates execution if the specified condition is not met.} statements, which are 
conditions that must be met for the contract to execute correctly. 
These conditions serve as the properties that Echidna will attempt to 
falsify during the fuzz testing process.

The goal of this report is to evaluate the effectiveness of Echidna 
in identifying potential vulnerabilities in the Taxpayer.sol contract. 
By examining how Echidna handles various edge cases and unconsidered 
behaviors, we aim to contribute to the broader discussion on improving 
the security of smart contracts.

\section{Other testing tools}
There are several tools available for conducting security checks on smart contracts, each designed to identify and mitigate potential vulnerabilities that could compromise the integrity and security of blockchain-based applications. Solidity static analyzers such as Myhtil and Slither\footnote{Already included into Echidna stack} are widely used to perform automated scans of smart contract code, flagging potential security issues. 
\subsection{Mythril}
Mythril is a powerful open-source security analysis tool specifically designed for Ethereum smart contracts. It performs static and dynamic analysis to detect a wide range of security issues, including potential vulnerabilities such as reentrancy attacks, integer overflows, and more.

Mythril supports various installation methods, including pip (Python package manager) and Docker. 
You can find detailed installation instructions on the official Mythril 
GitHub repository: \texttt{\href{https://github.com/ConsenSys/mythril}{github.com/ConsenSys/mythril}}. 
The method chosed in this report is via Docker due to compatibility with python3.12. 
Below there are execution command and respective output given by tool.

Before we look at what changes are needed to make the contract more secure and robust, let's take a look at what Mythril's report on the contract provided. (currently available as original.Taxpayer.sol)
\begin{minted}{bash}
$: docker run -v $(pwd):/tmp mythril/myth analyze /tmp/original.Taxpayer.sol
\end{minted}
\begin{minted}[breaklines]{bash}
==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Low
Contract: Taxpayer
Function name: transferAllowance(uint256)
PC address: 614
Estimated Gas Usage: 10205 - 99568
A call to a user-supplied address is executed.
An external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.
--------------------
In file: /tmp/original.Taxpayer.sol:56

sp.getTaxAllowance()

--------------------
Caller: [CREATOR], function: marry(address), txdata: 0xbccb358e000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef, decoded_data: ('0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',), value: 0x0
Caller: [ATTACKER], function: transferAllowance(uint256), txdata: 0x5f68c4390000000000000000000000000000000000000000000000000000000000001121, decoded_data: (4385,), value: 0x0
\end{minted}
and analog results are available also for
\begin{minted}[breaklines]{bash}
56.    sp.setTaxAllowance(sp.getTaxAllowance()+change)
47.    sp.setSpouse(address(0))
48.    spouse = address(0)
\end{minted}
As part of the security analysis conducted on the provided smart contract, Mythril revealed a number of functions that could have potential vulnerabilities. 
The full report of this analysis is available in the attached Mythril.report file available on repository\footnote{\href{https://github.com/Owanesh/SSA2324/blob/main/report/mythril.report}{github.com/owanesh/SSA2324/blob/master/report/mythril.report}}. 
The findings highlight several areas of concern, including possible risks related to 
reentrancy\footnote{Reentrancy vulnerability in smart contracts occurs when external calls can be reentered before completing the initial operation, potentially leading to unintended and malicious behavior.} (line 159 of report). 
In addition, it should be noted that the synergic integration of Mythril with Echidna provided substantial support in defining the constraints (require) necessary to mitigate the identified vulnerabilities. The combination of these two powerful resources provides a comprehensive overview of contract security.
At the end of listed enhancement described in this report, the result of Mythril is this reported below
\begin{minted}[breaklines]{bash}
    $: docker run -v $(pwd):/tmp mythril/myth analyze /tmp/Taxpayer.sol
    >>> The analysis was completed successfully. No issues were detected.
    $: docker run -v $(pwd):/tmp mythril/myth analyze /tmp/TaxpayerTesting.sol
    >>> The analysis was completed successfully. No issues were detected.
\end{minted}

\section{Echidna setup}
In order to write a full suite of tests, echidna offers two way o write a Tester contract. The first one represented below, is a test with a sort of whitelist on method which are allowed to be called.\footnote{\href{https://github.com/crytic/echidna/wiki/How-to-use-Echidna-with-multiple-contracts}{github.com/crytic/echidna/wiki/How-to-use-Echidna-with-multiple-contracts}}

Another method is by inheritance
\begin{minted}[linenos,breaklines, firstnumber=1, label=TaxpayerTesting.sol,labelposition=topline, frame=single]{solidity}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "./Taxpayer.sol";

constructor() Taxpayer(address(0), address(0)) {
    alpha = new Taxpayer(address(0), address(0));
    bravo = new Taxpayer(address(0), address(0));
    for (uint i = 0; i < ADULT_AGE; i++) {
        alpha.haveBirthday();
        bravo.haveBirthday();
    }
    bravo.marry(address(alpha));
    alpha.marry(address(bravo));
}
\end{minted}
By inheriting from Taxpayer, the testing contract gains access to all the public and external functions of Taxpayer, enabling comprehensive testing without the need for explicit method declarations in TaxpayerTesting. This approach can enhance the efficiency of testing, especially in scenarios where extensive coverage of the target contract's functionality is desired. Additionally, the second method seems to align with a fuzzer-based testing strategy, wherein automatic identification of public methods is crucial for generating diverse inputs during testing, as opposed to relying on a predefined whitelist. The decision to adopt the second method is likely driven by the desire for flexibility, automation, and a more dynamic testing environment.
\section{If person x is married to person y, then person y should be married to person x}
This function can be securely validated only through the proper execution of their respective marry functions. It is crucial that both marry functions are called accurately to maintain the consistency of marriage states. Therefore, the validation of this property is inherently tied to the accurate implementation and execution of the marry functions. An optimal implementation might involve code optimizations, ensuring that the marry function of one person correctly invokes the marry function of the spouse, thereby making the contract more robust and resilient to potential logic errors that could compromise the correctness of the application. 
\begin{minted}{solidity}
function marry(address newSpouse) public {
    <all_require()_conditions>
    spouse=newSpouse;
    isMarried = true;
    if(!Taxpayer(address(newSpouse)).getIsMarried())
        Taxpayer(address(newSpouse)).marry(address(this));
}
\end{minted}

\textit{In this way we achieve the isMarried status on both contract with one transaction.}

The decision to not implement the marriage verification within the marry function could stem from the principle of separation of concerns and the idea that a contract should ideally modify only its own state. In a well-designed system, each contract should be responsible for managing its own data and logic independently
\subsection{Analyze the original code}
\begin{minted}[linenos, breaklines, firstnumber=40, label=original.Taxpayer.sol, labelposition=topline, frame=single]{solidity}
function marry(address new_spouse) public {
    spouse = new_spouse;
    isMarried = true;
    }
\end{minted}
Looking at these lines of code, one can immediately see some critical issues that make the contract vulnerable to potential unwanted behavior. This is caused by the absence of some security measures within the code Let us delve into the technical description of some possible vulnerabilities:
 
 \begin{itemize}
        \small
    \item Ability to marry a nonexistent address (address(0))
    \item Self-Marriage Exploitation:
    \begin{itemize}
            \small
        \item The code lacks a check to ensure the \texttt{newSpouse} address is different from the caller's address.
        \item Allows a user to marry themselves, potentially leading to unexpected complications.
    \end{itemize}

    \item Overwriting Past Marriages:
    \begin{itemize}
            \small
        \item No verification for whether the caller is already married before executing a new marriage.
        \item Enables repetitive invocation of the \texttt{marry} function, overwriting past marriages without constraints.
    \end{itemize}
\end{itemize}
There are then other useful checks to increase the robustness of the code and avoid :
\begin{itemize}
    \small
\item You cannot marry twice the same address
\item You cannot marry if your status is already set to \texttt{isMarried=True}
\item Your spouse address needs to be a valid address
\end{itemize}
Finally, some inserted checks are more "logical" such as:
\begin{itemize}
    \small
    \item You cannot marry with your parents
    \item You cannot marry if your are under sixteen
    \item Your spouse needs to be not married or divorced by previous marriage
\end{itemize}
A possible implementation of requirements contraints is listed below. Every \texttt{<require()>} function is composed by \texttt{<condition>} and \texttt{<reason>}. The best way to obtain a 100\% retrocompatible code.
\begin{minted}[linenos, breaklines, firstnumber=40, label=Taxpayer.sol, labelposition=topline, frame=single]{solidity}
function marry(address newSpouse) public {
    require(age > 16, "You must have at least 16 years old");
    require(
        newSpouse != address(parent1) && newSpouse != address(parent2),
        "You cannoy marry with your parents"
    ); // marriage with siblings is allowed by code
    require(newSpouse != address(this), "You cannot marry with yourself");
    require(newSpouse != getSpouse(), "Already married to this spouse");
    require(
        spouse == address(0) && getIsMarried() == false,
        "Already married"
    );
    require(newSpouse != address(0), "Invalid spouse address");
    require(
        address(Taxpayer(address(newSpouse))).code.length > 0,
        "Invalid spouse, is it already born?" //exploitable if new_spouse has another type of contract
    );
    require(
        (Taxpayer(address(newSpouse)).getSpouse() == address(0) &&
            Taxpayer(address(newSpouse)).getIsMarried() == false) ||
            (Taxpayer(address(newSpouse)).getIsMarried() == true &&
                Taxpayer(address(newSpouse)).getSpouse() == address(this)),
        "Your partner should be single or at least not married with another person"
    );
    spouse = newSpouse;
    isMarried = true;
}
\end{minted}
One way to check that all these constraints are valid and do not block the normal behavior of the contract is to use echidna, which will do fuzztesting on our contract. Are published below the written test, and the results obtained with \texttt{original.Taxpayer.sol} and those obtained as a result of the modifications. In this way used approach is similar to TDD\footnote{TDD, a software development method, advocates for test creation preceding code writing.} (mixed with BDD\footnote{BDD is a collaborative software development approach emphasizing natural language specifications and executable tests.}), where the requirements are written in the test, and after that the code is modified to be compatible.

\begin{minted}[linenos,breaklines, firstnumber=65,label=TaxpayerTesting.sol, labelposition=topline, frame=single]{solidity}
function echidna_simple_marry() public view returns (bool) {
    bool alpha_to_bravo = alpha.getSpouse() == address(bravo) &&
        alpha.getSpouse() != address(0);
    return alpha_to_bravo;
}

function echidna_both_married() public view returns (bool) {
    bool alpha_to_bravo = alpha.getSpouse() == address(bravo) &&
        alpha.getSpouse() != address(0);
    bool bravo_to_alpha = bravo.getSpouse() == address(alpha) &&
        bravo.getSpouse() != address(0);
    return alpha_to_bravo && bravo_to_alpha;
}

function echidna_divorce() public returns (bool) {
    bravo.divorce();
    bool alpha_is_divorced = alpha.getSpouse() == address(0) &&
        alpha.getIsMarried();
    bool bravo_is_divorced = bravo.getSpouse() == address(0) &&
        !bravo.getIsMarried();
    return alpha_is_divorced && bravo_is_divorced;
}
\end{minted} 

\begin{minted}[label=results on original.Taxpayer.sol, labelposition=topline, frame=single]{bash}
echidna_both_married: failed!   [X]
Call sequence:
    marry(0x62d69f6867a0a084c6d313943dc22023bc263691)
    divorce()

echidna_simple_marry: failed!   [X]
Call sequence:
    setSpouse(0xb4c79dab8f259c7aee6e5b2aa729821864227e84)
    divorce()

echidna_divorce: failed!    [X]
Call sequence:
    marry(0x62d69f6867a0a084c6d313943dc22023bc263691)
    divorce()

Event sequence:
error Revert 0x
\end{minted} 
The execution results from Echidna reveal failures in three distinct scenarios. Echidna finds with fuzzing action, a call-sequence able to break the tests. All finded path include an alteration of \texttt{spouse} variable, via \texttt{setSpouse()} called arbitrary or via \texttt{marry()}. With original code some of those scenario are allowed because there are no control on validity of spouse nor validity on \texttt{setSpouse()} call.
In order to fix is important to analyze lines 47,48,52 and 53 of Taxpayer.sol, added require() ensure that newSpouse is a valid address, and the caller contract is not already married with another spouse.
To ensure that a contract should be married only with another contract already deployed on blockhain, the control used is \mintinline{solidity}{address(Taxpayer(address(newSpouse))).code.length > 0}\footnote{\href{https://stackoverflow.com/a/74511610}{stackoverflow.com/a/74511610}}
\begin{minted}[label=results on Taxpayer.sol, labelposition=topline, frame=single]{bash}
echidna_both_married: passing
echidna_simple_marry: passing
echidna_divorce: passing
\end{minted} 
 
\section{Married persons can pool their tax allowance as long as the sum of their tax allowances remains the same}
\begin{minted}[linenos, label=Taxpayer.sol, labelposition=topline, frame=single,firstnumber=55]{solidity}
function transferAllowance(uint change) public {
    tax_allowance = tax_allowance - change;
    Taxpayer sp = Taxpayer(address(spouse));
    sp.setTaxAllowance(sp.getTaxAllowance()+change);
}
\end{minted}
\begin{minted}[linenos, label=Taxpayer.sol, labelposition=topline, frame=single,firstnumber=110]{solidity}
function transferAllowance(uint256 change) public {
    require(
        change > 0,
        "Don't waste gas, save the world, use proper change value"
    );
    require(taxAllowance >= change, "Insufficient tax allowance");
    require(
        getIsMarried() && getSpouse() != address(0),
        "You have to be married before pooling tax allowance"
    );
    taxAllowance -= change;
    Taxpayer sp = Taxpayer(address(spouse));
    require(
        sp.getSpouse() == address(this) && sp.getIsMarried(),
        "You cannot change allowance of person not married with you"
    );
    sp.setTaxAllowance(sp.getTaxAllowance() + change);
}
\end{minted}
\begin{minted}[linenos,firstnumber=71,label=original.Taxpayer.sol,labelposition=topline,frame=single]{solidity}
function setTaxAllowance(uint ta) public {
    tax_allowance = ta;
}
\end{minted}

\begin{minted}[linenos,firstnumber=100,label=Taxpayer.sol,labelposition=topline,frame=single]{solidity}
function setTaxAllowance(uint256 ta) public {
    require(
        ta > 0,
        "Don't waste gas, save the world, use proper change value"
    );
    require(
        getSpouse() != address(0),
        "Someone that isn't married with you, tried to change your tax allowance"
    );
    require(
        ta > getTaxAllowance(),
        "Someone tries to decrease illegally your tax allowance"
    );
    Taxpayer spoused = Taxpayer(address(getSpouse()));
    require(
        ((getAge() < 65 &&
            spoused.getAge() < 65 &&
            ta + spoused.getTaxAllowance() == 2 * DEFAULT_ALLOWANCE) ||
            (getAge() >= 65 &&
                spoused.getAge() >= 65 &&
                ta + spoused.getTaxAllowance() == 2 * ALLOWANCE_OAP) ||
            (getAge() < 65 &&
                spoused.getAge() >= 65 &&
                ta + spoused.getTaxAllowance() ==
                DEFAULT_ALLOWANCE + ALLOWANCE_OAP) ||
            (getAge() >= 65 &&
                spoused.getAge() < 65 &&
                ta + spoused.getTaxAllowance() ==
                DEFAULT_ALLOWANCE + ALLOWANCE_OAP)),
        "Tax pooling violation"
    );
    taxAllowance = ta;
}
\end{minted}
\section{People aged 65 and over have a higher tax allowance, of 7000}
To introduce this functionality within the code, it was necessary to modify the \mintinline{solidity}{haveBirthday()} function, granting an extra \texttt{ALLOWANCE\_OAP-DEFAULT\_ALLOWANCE} to the contract when it reaches an age of 65.
The choice was made to use increment by difference so as not to overwrite potential allowance changes. (In fact, it would otherwise have been possible to transfer all the allowance, getting to 0, and then at age 65 having 7000 again.)
\begin{minted}[linenos,breaklines, firstnumber=167,label=Taxpayer.sol, labelposition=topline, frame=single]{solidity}
function haveBirthday() public {
    age++;
    if (age == 65 && !getIsMarried()) 
        taxAllowance += (ALLOWANCE_OAP - DEFAULT_ALLOWANCE); // added lines
    else if (age == 65 && getIsMarried()) 
        this.setTaxAllowance(this.getTaxAllowance()+(ALLOWANCE_OAP - DEFAULT_ALLOWANCE));
}
\end{minted} 
The need to have to distinguish the state in which isMarried is derived from the fact that one of the assumptions of this report, is that certain functions can only be called in certain contexts. And among these is \mintinline{solidity}{setTaxAllowance(uint ta)}, which can only be called via \mintinline{solidity}{transferAllowance(uint change)}, which can by definition only be called if \mintinline{solidity}{isMarried=true}.

The choice to use the set method instead of direct assignment comes from wanting to further control the validity of operations.
\section{Extras}
\subsection{Useful (getter) function}
Two get functions were added to improve the effectiveness on validation checks. These functions do not alter the state of the contract in fact they are defined with \mintinline{solidity}{view} identifier.
\begin{minted}[linenos,breaklines, firstnumber=179, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
function getAge() public view returns (uint256) {
    return age;
}

function getIsMarried() public view returns (bool) {
    return isMarried;
}
\end{minted}
\subsection{Requirements}
Some conditions have been added to make the code more "real," preventing undesirable behavior. The code provided does not require any of these changes, so they can be removed, but these provide robustness to the code and "logical" continuity.
\subsubsection{Can born only from addr(0x0) or married couple}
For example a constraint added require a contract needs to be created with 2 parents options.
\begin{itemize}
    \small
    \item You can have parent1 and 2 as address(0)
    \item You can have parent1 and 2 different than address(0) only if they are married each others.
\end{itemize}
The choice of second requirements isn't needed, of course in real life you can have a baby out of a marriage, but for this scenario we assume you cannot.
\begin{minted}[linenos,breaklines, firstnumber=19, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
constructor(address p1, address p2) {
    require(
        (p1 == address(0) && p2 == address(0)) ||
            (Taxpayer(p1).getSpouse() == p2 &&
                Taxpayer(p2).getSpouse() == p1),
        "A new born is allowed only form init and married couple"
    );
    age = 0;
    isMarried = false;
    parent1 = p1;
    parent2 = p2;
    spouse = (address(0));
    income = 0;
    tax_allowance = DEFAULT_ALLOWANCE;
}
\end{minted}
This improvement is validated by the following test which operates through the use of a \mintinline{solidity}{try{}catch{}} statement.
\begin{minted}[linenos,breaklines, firstnumber=87, label=TaxpayerTesting.sol,labelposition=topline, frame=single]{solidity}
function echidna_block_spawn_of_orphan() public returns (bool) {
    try new Taxpayer(address(1), address(2)) returns (Taxpayer) {
        return false;
    } catch {
        return true; // exception was raised
    }
}
\end{minted}
As you can read from the test, the code tries to create a contract with \mintinline{solidity}{address(1)} and \mintinline{solidity}{address(2)} as parent1 and parent2 respectively. But the expected result is that the test fails because of the require on line 21 of Taxpayer.sol. So we catch this event inside the catch{} block.
Another test, more easy to read is shown below: (Notice: alpha and bravo are married from constructor)
\begin{minted}[linenos,breaklines, firstnumber=37, label=TaxpayerTesting.sol,labelposition=topline, frame=single]{solidity}
function echidna_couple_make_a_baby() public returns (bool) {
    try new Taxpayer(address(alpha), address(bravo)) {
        return true; // works successfully
    } catch {
        return false; // an exception was raised by contract
    }
}
\end{minted}
\subsubsection{setSpouse valid only for divorce purpose}
The one proposed is an assumption that was made to make the code fluid, namely that setSpouse can be called as from the original code, only via the \mintinline{solidity}{divorce()} function. Obviously from the original code no such constraint is present, but the decision to include it forces users not to be able to call a \mintinline{solidity}{setSpouse(address sp)} on themselves with a dummy or invalid address, thus avoiding unwanted behavior.
\begin{minted}[linenos,breaklines, firstnumber=100, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
    function setSpouse(address sp) public {
    require(sp != address(this), "You cannot call setSpouse with yourself");
    require(
        (getSpouse() != address(0) && getIsMarried() && sp == address(0)),
        "You are already married, you can call this function only for divorce purpose now"
    );
    spouse = (address(sp));
}
\end{minted}
With the condition placed in the require, three conditions must be validated simultaneously "sp" as an input parameter must be equal to \mintinline{solidity}{addr(0)} the contract executing the \mintinline{solidity}{setSpouse(address sp)}  must be \mintinline{solidity}{isMarried=True} and then its \mintinline{solidity}{getSpouse()} must return an address other than \mintinline{solidity}{addr(0)}
\subsubsection{Ensure to be married before divorce}
\subsubsection{Solve tax pooling before divorce}

\begin{minted}[linenos,breaklines, firstnumber=70, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
function divorce() public {
    require(
        getSpouse() != address(0) && getIsMarried(),
        "You're not already married"
    );
    Taxpayer sp = Taxpayer(address(spouse));
    require(
        sp.getSpouse() == address(this) && sp.getIsMarried(),
        "That person isn't married with you"
    );
    require(
        (getTaxAllowance() == DEFAULT_ALLOWANCE && age < 65) ||
            ((getTaxAllowance() == ALLOWANCE_OAP && age >= 65) &&
                (sp.getTaxAllowance() == DEFAULT_ALLOWANCE && sp.getAge() < 65)) ||
            (sp.getTaxAllowance() == ALLOWANCE_OAP && sp.getAge() >= 65),
        "Before divorcing, fix your tax pool allowance"
    ); 
    /**
        if(getAge()>=65) {setTaxAllowance(ALLOWANCE_OAP);}
        else {setTaxAllowance(DEFAULT_ALLOWANCE);}
     */
    sp.setSpouse(address(0));
    spouse = address(0);
    /*
    sp.divorce(); // instead of sp.setSpouse(address(0));
    */
    isMarried = false;
}
\end{minted}
\subsection{Echidna through CI/CD pipeline}

\section{Conclusion}
    \lipsum[6]  % Replace with your conclusion.

% Bibliography
\printbibliography

\end{document}
