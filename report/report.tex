\documentclass{article}

% Use packages for additional functionality
\usepackage{titlesec}   % Customize section titles
\usepackage{lipsum}      % Generate placeholder text
\usepackage{biblatex}    % Handle bibliography
\usepackage[skins,minted]{tcolorbox}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage[left=3.3cm, right=3cm, top=3.3cm, bottom=3cm]{geometry}
\hyphenation{exam-ple}

\setminted{fontsize=\footnotesize}
% Title and Author Information
\title{Security in Software Application Assignment}
\author{Owanesh}
\date{Jan 2024}

% Define Section and Subsection Formatting
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}[:]

\begin{document}

% Create Title
\maketitle

% Abstract
\begin{abstract}
    This report will analyze the security of a provided Taxpayer.sol 
    contract. Security will be analyzed and tested through the use of 
    the Echidna tool. To make the code more robust, throughout the report 
    only \mintinline{solidity}{require()} functions will be used to increase backward compatibility. Of the various possible ways including adding invariants or directly modifying the code, the use of requires was preferred as they are more versatile.

    This report is part of the Security in Software Application course at La Sapienza University of Rome. It is therefore not intended as a scientific research paper, but as a report for laboratory exercise.
\end{abstract}

% Table of Contents
\tableofcontents

% Sections
\section{Introduction to fuzz testing}
Fuzz testing is a dynamic testing technique used to discover coding 
errors and security loopholes in software, by inputting massive amounts 
of random data, called fuzz, to the system in an attempt to make it crash. 
This technique is especially effective in finding vulnerabilities in 
software applications, including smart contracts like in this report.

In the context of smart contracts, other popular tool for 
fuzz testing is Malticore and Foundry. Echidna is an Haskell\footnote{Haskell is a functional programming language} program designed 
for fuzzing/property-based testing of Ethereum smart contracts. 
It uses sophisticated grammar-based fuzzing campaigns based 
on a contract ABI\footnote{A contract ABI, or Application Binary Interface, in the context of Ethereum, is essentially a specification for how to interact with a contract on the Ethereum blockchain} to falsify user-defined predicates or Solidity assertions.
Instead of other softwares, Echidna includes also other tools like slither.

One of the key features of Echidna is its unique 'property-based fuzzing',
 which tries to falsify user-defined invariants (properties) 
 instead of looking for crashes like a traditional fuzzer. 
 This makes it particularly effective at finding subtle vulnerabilities that might not be caught by other types of testing.

This report focuses on the application of fuzz testing to 
the Taxpayer.sol contract, a smart contract in the Ethereum blockchain. 
The contract includes several \texttt{require()}\footnote{The require() function in Solidity is used for input validation and conditional checking. It throws an exception and terminates execution if the specified condition is not met.} statements, which are 
conditions that must be met for the contract to execute correctly. 
These conditions serve as the properties that Echidna will attempt to 
falsify during the fuzz testing process.

The goal of this report is to evaluate the effectiveness of Echidna 
in identifying potential vulnerabilities in the Taxpayer.sol contract. 
By examining how Echidna handles various edge cases and unconsidered 
behaviors, we aim to contribute to the broader discussion on improving 
the security of smart contracts.

\section{Other testing tools}
There are several tools available for conducting security checks on smart contracts, each designed to identify and mitigate potential vulnerabilities that could compromise the integrity and security of blockchain-based applications. Solidity static analyzers such as Myhtil and Slither\footnote{Already included into Echidna stack} are widely used to perform automated scans of smart contract code, flagging potential security issues. 
\subsection{Mythril}
Mythril is a powerful open-source security analysis tool specifically designed for Ethereum smart contracts. It conducts static and dynamic analyses to identify a broad spectrum of security issues, including potential vulnerabilities such as reentrancy attacks, integer overflows, and more.

Mythril supports various installation methods, including pip (Python package manager) and Docker.
Detailed installation instructions can be found on the official Mythril GitHub repository: \texttt{\href{https://github.com/ConsenSys/mythril}{github.com/ConsenSys/mythril}}.
The method chosen in this report is via Docker due to compatibility with Python 3.12.
Below, you will find the execution command and the respective output provided by the tool.

Before we delve into the changes needed to enhance the contract's security and robustness, let's review the report that Mythril generated for the provided contract (currently available as original.Taxpayer.sol).
\begin{minted}{bash}
$: docker run -v $(pwd):/tmp mythril/myth analyze /tmp/original.Taxpayer.sol
\end{minted}
\begin{minted}[breaklines]{bash}
==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Low
Contract: Taxpayer
Function name: transferAllowance(uint256)
PC address: 614
Estimated Gas Usage: 10205 - 99568
A call to a user-supplied address is executed.
An external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.
--------------------
In file: /tmp/original.Taxpayer.sol:56

sp.getTaxAllowance()

--------------------
Caller: [CREATOR], function: marry(address), txdata: 0xbccb358e000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef, decoded_data: ('0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',), value: 0x0
Caller: [ATTACKER], function: transferAllowance(uint256), txdata: 0x5f68c4390000000000000000000000000000000000000000000000000000000000001121, decoded_data: (4385,), value: 0x0
\end{minted}
and analog results are available also for
\begin{minted}[breaklines]{bash}
56.    sp.setTaxAllowance(sp.getTaxAllowance()+change)
47.    sp.setSpouse(address(0))
48.    spouse = address(0)
\end{minted}
As part of the security analysis conducted on the provided smart contract, Mythril revealed a number of functions that could have potential vulnerabilities. 
The full report of this analysis is available in the attached Mythril.report file available on repository\footnote{\href{https://github.com/Owanesh/SSA2324/blob/main/report/mythril.report}{github.com/owanesh/SSA2324/blob/master/report/mythril.report}}. 
The findings highlight several areas of concern, including possible risks related to 
reentrancy\footnote{Reentrancy vulnerability in smart contracts occurs when external calls can be reentered before completing the initial operation, potentially leading to unintended and malicious behavior.} (line 159 of report). 
In addition, it should be noted that the synergic integration of Mythril with Echidna provided substantial support in defining the constraints (require) necessary to mitigate the identified vulnerabilities. The combination of these two powerful resources provides a comprehensive overview of contract security.
At the end of listed enhancement described in this report, the result of Mythril is this reported below
\begin{minted}[breaklines]{bash}
    $: docker run -v $(pwd):/tmp mythril/myth analyze /tmp/Taxpayer.sol
    >>> The analysis was completed successfully. No issues were detected.
    $: docker run -v $(pwd):/tmp mythril/myth analyze /tmp/TaxpayerTesting.sol
    >>> The analysis was completed successfully. No issues were detected.
\end{minted}

\section{Echidna setup}
In order to write a full suite of tests, echidna offers two way of write a Tester contract. The first one represented below, is a test with a sort of whitelist on methods which are allowed to be called.\footnote{\href{https://github.com/crytic/echidna/wiki/How-to-use-Echidna-with-multiple-contracts}{github.com/crytic/echidna/wiki/How-to-use-Echidna-with-multiple-contracts}}

Another method is by inheritance
\begin{minted}[linenos,breaklines, firstnumber=1, label=TaxpayerTesting.sol,labelposition=topline, frame=single]{solidity}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "./Taxpayer.sol"; 

contract TaxpayerTesting is Taxpayer {
    uint constant ADULT_AGE = 18;
    uint constant ADULT_OLD_AGE = 65;
    Taxpayer alpha;
    Taxpayer bravo;

    constructor() Taxpayer(address(0), address(0)) {
        alpha = new Taxpayer(address(0), address(0));
        bravo = new Taxpayer(address(0), address(0));
        for (uint i = 0; i < ADULT_AGE; i++) {
            alpha.haveBirthday();
            bravo.haveBirthday();
        }
        bravo.marry(address(alpha));
        alpha.marry(address(bravo));
    }
...
\end{minted}
By inheriting from Taxpayer, the testing contract gains access to all the public and external functions of Taxpayer, enabling comprehensive testing without the need for explicit method declarations in TaxpayerTesting. This approach can enhance the efficiency of testing, especially in scenarios where extensive coverage of the target contract's functionality is desired. Additionally, the second method seems to align with a fuzzer-based testing strategy, wherein automatic identification of public methods is crucial for generating diverse inputs during testing, as opposed to relying on a predefined whitelist. The decision to adopt the second method is likely driven by the desire for flexibility, automation, and a more dynamic testing environment.
\section{If person x is married to person y, then person y should be married to person x}
This function can be securely validated only through the proper execution of their respective marry functions. It is crucial that both marry functions are called accurately to maintain the consistency of marriage states. Therefore, the validation of this property is inherently tied to the accurate implementation and execution of the marry functions. An optimal implementation might involve code optimizations, ensuring that the marry function of one person correctly invokes the marry function of the spouse, thereby making the contract more robust and resilient to potential logic errors that could compromise the correctness of the application. 
\begin{minted}{solidity}
function marry(address newSpouse) public {
    <all_require()_conditions>
    spouse=newSpouse;
    isMarried = true;
    if(!Taxpayer(address(newSpouse)).getIsMarried())
        Taxpayer(address(newSpouse)).marry(address(this));
}
\end{minted}

\textit{In this way we achieve the isMarried status on both contract with one transaction.}

The decision to not implement the marriage verification within the marry function could stem from the principle of separation of concerns and the idea that a contract should ideally modify only its own state. In a well-designed system, each contract should be responsible for managing its own data and logic independently.



\break
\subsection{Analyze the original code}
\label{sec:original_marry}
\begin{minted}[linenos, breaklines, firstnumber=40, label=original.Taxpayer.sol, labelposition=topline, frame=single]{solidity}
function marry(address new_spouse) public {
    spouse = new_spouse;
    isMarried = true;
    }
\end{minted}
Looking at these lines of code, one can immediately see some critical issues that make the contract vulnerable to potential unwanted behavior. This is caused by the absence of some security measures within the code Let us delve into the technical description of some possible vulnerabilities:
 
 \begin{itemize}
        \small
    \item Ability to marry a nonexistent address (address(0))
    \item Self-Marriage Exploitation:
    \begin{itemize}
            \small
        \item The code lacks a check to ensure the \texttt{newSpouse} address is different from the caller's address.
        \item Allows a user to marry themselves, potentially leading to unexpected complications.
    \end{itemize}

    \item Overwriting Past Marriages:
    \begin{itemize}
            \small
        \item No verification for whether the caller is already married before executing a new marriage.
        \item Enables repetitive invocation of the \texttt{marry} function, overwriting past marriages without constraints.
    \end{itemize}
\end{itemize}
There are then other useful checks to increase the robustness of the code and avoid : 
\begin{itemize}
    \small
\item You cannot marry twice the same address
\item You cannot marry if you are already married, then \texttt{getSpouse()$\neq$address(0)}
\item Your spouse address needs to be a valid address
\end{itemize}
Finally, some inserted checks are more "logical" such as:
\begin{itemize}
    \small
    \item You cannot marry with your parents
    \item You cannot marry if your are under sixteen
    \item Your spouse needs to be not married or divorced by previous marriage
\end{itemize}
A possible implementation of requirements contraints is listed below. Every \texttt{<require()>} function is composed by \texttt{<condition>} and \texttt{<reason>}. The best way to obtain a 100\% retrocompatible code.
\begin{minted}[linenos, breaklines, firstnumber=40, label=Taxpayer.sol, labelposition=topline, frame=single]{solidity}
function marry(address newSpouse) public {
    require(age > 16, "You must have at least 16 years old");
    require(
        newSpouse != address(parent1) && newSpouse != address(parent2),
        "You cannoy marry with your parents"
    ); // marriage with siblings is allowed by code
    require(newSpouse != address(this), "You cannot marry with yourself");
    require(newSpouse != getSpouse(), "Already married to this spouse");
    require(
        spouse == address(0) && getIsMarried() == false,
        "Already married"
    );
    require(newSpouse != address(0), "Invalid spouse address");
    require(
        address(Taxpayer(address(newSpouse))).code.length > 0,
        "Invalid spouse, is it already born?"
    );
    require(
        (Taxpayer(address(newSpouse)).getSpouse() == address(0) &&
            Taxpayer(address(newSpouse)).getIsMarried() == false) ||
            (Taxpayer(address(newSpouse)).getIsMarried() == true &&
                Taxpayer(address(newSpouse)).getSpouse() == address(this)),
        "Your partner should be single or at least not married with another person"
    );
    spouse = newSpouse;
    isMarried = true;
}
\end{minted}
One way to check that all these constraints are valid and do not block the normal behavior of the contract is to use echidna, which will do fuzztesting on the contract. Are published below the written test, and the results obtained with \texttt{original.Taxpayer.sol} and those obtained as a result of the modifications. In this way used approach is similar to TDD\footnote{TDD, a software development method, advocates for test creation preceding code writing.} (mixed with BDD\footnote{BDD is a collaborative software development approach emphasizing natural language specifications and executable tests.}), where the requirements are written in the test, and after that the code is modified to be compatible.

\begin{minted}[linenos,breaklines, firstnumber=65,label=TaxpayerTesting.sol, labelposition=topline, frame=single]{solidity}
function echidna_simple_marry() public view returns (bool) {
    bool alpha_to_bravo = alpha.getSpouse() == address(bravo) &&
        alpha.getSpouse() != address(0);
    return alpha_to_bravo;
}

function echidna_both_married() public view returns (bool) {
    bool alpha_to_bravo = alpha.getSpouse() == address(bravo) &&
        alpha.getSpouse() != address(0);
    bool bravo_to_alpha = bravo.getSpouse() == address(alpha) &&
        bravo.getSpouse() != address(0);
    return alpha_to_bravo && bravo_to_alpha;
}

function echidna_divorce() public returns (bool) {
    bravo.divorce();
    bool alpha_is_divorced = alpha.getSpouse() == address(0) &&
        alpha.getIsMarried();
    bool bravo_is_divorced = bravo.getSpouse() == address(0) &&
        !bravo.getIsMarried();
    return alpha_is_divorced && bravo_is_divorced;
}
\end{minted} 

\begin{minted}[label=results on original.Taxpayer.sol, labelposition=topline, frame=single]{bash}
echidna_both_married: failed!   [X]
Call sequence:
    marry(0x62d69f6867a0a084c6d313943dc22023bc263691)
    divorce()

echidna_simple_marry: failed!   [X]
Call sequence:
    setSpouse(0xb4c79dab8f259c7aee6e5b2aa729821864227e84)
    divorce()

echidna_divorce: failed!    [X]
Call sequence:
    marry(0x62d69f6867a0a084c6d313943dc22023bc263691)
    divorce()

Event sequence:
error Revert 0x
\end{minted} 
The execution results from Echidna reveal failures in three distinct scenarios. Echidna finds with fuzzing action, a call-sequence able to break the tests. All found path include an alteration of \texttt{spouse} variable, via \texttt{setSpouse()} called arbitrary or via \texttt{marry()}. With original code some of those scenario are allowed because there are no controls on validity of spouse nor validity on \texttt{setSpouse()} call.
In order to fix is important to analyze lines 47,48,52 and 53 of Taxpayer.sol, added require() ensure that newSpouse is a valid address, and the caller contract is not already married with another spouse.
To ensure that a contract should be married only with another contract already deployed on blockhain, the control used is \mintinline{solidity}{address(Taxpayer(address(newSpouse))).code.length > 0}\footnote{\href{https://stackoverflow.com/a/74511610}{stackoverflow.com/a/74511610}}.
A proposed fix on setSpouse also in described on \hyperref[sec:setspouse]{setSpouse()} section.
\begin{minted}[label=results on Taxpayer.sol, labelposition=topline, frame=single]{bash}
echidna_both_married: passing
echidna_simple_marry: passing
echidna_divorce: passing
\end{minted} 
 
\section{Married persons can pool their tax allowance as long as the sum of their tax allowances remains the same}
The tax pooling, based on the provided code, appears to have several issues. The foremost concern is the ability to invoke the method with a \texttt{change} value higher than the current available \texttt{tax\_allowance}. This would inevitably lead to a runtime error as \texttt{tax\_allowance} is defined as a uint. It is always preferable to prevent runtime errors rather than encountering them during execution.
To address this potential issue, a condition has been introduced to ensure that the available \texttt{tax\_allowance} is greater than the value of \texttt{change} to be transferred. Additionally, an extra check (\textit{not explicitly requested}) has been implemented to prevent "dummy" operations, ensuring that the input value of \texttt{change} is greater than zero.
\begin{minted}[linenos, label=original.Taxpayer.sol, labelposition=topline, frame=single,firstnumber=55]{solidity}
function transferAllowance(uint change) public {
    tax_allowance = tax_allowance - change;
    Taxpayer sp = Taxpayer(address(spouse));
    sp.setTaxAllowance(sp.getTaxAllowance()+change);
}
\end{minted}
Furthermore, the assignment specifies that tax pooling should only be granted to married couples. Hence, the introduction of the require statements in lines 116 and 122. The first ensures that the caller, i.e., the one initiating the transfer, is indeed married. The second checks for the reciprocity constraint, ensuring that the recipient is married to the caller.
\begin{minted}[linenos, label=Taxpayer.sol, labelposition=topline, frame=single,firstnumber=110]{solidity}
function transferAllowance(uint256 change) public {
    require(
        change > 0,
        "Don't waste gas, save the world, use proper change value"
    );
    require(taxAllowance >= change, "Insufficient tax allowance");
    require(
        getIsMarried() && getSpouse() != address(0),
        "You have to be married before pooling tax allowance"
    );
    taxAllowance -= change;
    Taxpayer sp = Taxpayer(address(spouse));
    require(
        sp.getSpouse() == address(this) && sp.getIsMarried(),
        "You cannot change allowance of person not married with you"
    );
    sp.setTaxAllowance(sp.getTaxAllowance() + change);
}
\end{minted}
Just as with the \mintinline{solidity}{transferAllowance(uint256 change)}, the original form of the \mintinline{solidity}{setTaxAllowance(uint256 ta)} function appears to have security issues, most notably the ability to assign any arbitrary value without any restrictions.

Before examining the applied modifications, it is essential to consider an assumption made during the project's development: specifically, that \mintinline{solidity}{setTaxAllowance(uint256 ta)} should only be called by one's spouse through the \mintinline{solidity}{transferAllowance(uint256 change)} function. This assumption is crucial for understanding the nature of the various \texttt{require()} statements that have been added.
\begin{minted}[linenos,firstnumber=71,label=original.Taxpayer.sol,labelposition=topline,frame=single]{solidity}
function setTaxAllowance(uint ta) public {
    tax_allowance = ta;
}
\end{minted}
With the assumptions established earlier and the previously discussed analysis of requirements for the \texttt{transferAllowance} function, understanding the importance of the initial three \texttt{require()} statements in the Taxpayer.sol code becomes more accessible.

There is then a final \texttt{require()} statement that validates the maximum sum a couple can obtain. Specifically, in the case of a couple where both members are under 65 years old, the sum of their \texttt{taxAllowance} must be equal to \texttt{2 * DEFAULT\_ALLOWANCE}.

Examining the code of \texttt{transferAllowance}, it's noticeable that the \texttt{change} parameter is subtracted first and then added to the spouse's \texttt{taxAllowance}. This approach simplifies the sum check since the \texttt{ta} parameter in \texttt{setTaxAllowance}  is already one of the two addends. The remaining analysis involves the \texttt{getTaxAllowance()}  of the spouse (\textit{which, in the previous step, has already been subtracted by \texttt{change} to exclude the scenario where it is considered twice}).
\begin{minted}[linenos,firstnumber=100,label=Taxpayer.sol,labelposition=topline,frame=single]{solidity}
function setTaxAllowance(uint256 ta) public {
    require(
        ta > 0,
        "Don't waste gas, save the world, use proper change value"
    );
    require(
        getSpouse() != address(0),
        "Someone that isn't married with you, tried to change your tax allowance"
    );
    require(
        ta > getTaxAllowance(),
        "Someone tries to decrease illegally your tax allowance"
    );
    Taxpayer spoused = Taxpayer(address(getSpouse()));
    require(
        ((getAge() < 65 &&
            spoused.getAge() < 65 &&
            ta + spoused.getTaxAllowance() == 2 * DEFAULT_ALLOWANCE) ||
            (getAge() >= 65 &&
                spoused.getAge() >= 65 &&
                ta + spoused.getTaxAllowance() == 2 * ALLOWANCE_OAP) ||
            (getAge() < 65 &&
                spoused.getAge() >= 65 &&
                ta + spoused.getTaxAllowance() ==
                DEFAULT_ALLOWANCE + ALLOWANCE_OAP) ||
            (getAge() >= 65 &&
                spoused.getAge() < 65 &&
                ta + spoused.getTaxAllowance() ==
                DEFAULT_ALLOWANCE + ALLOWANCE_OAP)),
        "Tax pooling violation"
    );
    taxAllowance = ta;
}
\end{minted}
\subsection{Testing}
\begin{minted}[label=TaxpayerTesting.sol, labelposition=topline, frame=single, firstnumber=125]{solidity}
function echidna_transfer_allowance() public returns (bool) {
    alpha.transferAllowance(4000);
    return
        bravo.getTaxAllowance() + alpha.getTaxAllowance() ==
        2 * DEFAULT_ALLOWANCE;
}
function echidna_transfer_huge_amount_of_allowance() public returns (bool) {
    try alpha.transferAllowance(40000) {
        return false;
    } catch {
        return true;
    }
}
\end{minted}

\begin{minted}[label=results on original.Taxpayer.sol, labelposition=topline, frame=single]{bash}
echidna_transfer_allowance: failed! [X]
    Call sequence:
        marry(0x62d69f6867a0a084c6d313943dc22023bc263691)
        transferAllowance(1)
    
echidna_transfer_huge_amount_of_allowance: failed! [X]
    Call sequence:
        setTaxAllowance(35514)
        setSpouse(0xb4c79dab8f259c7aee6e5b2aa729821864227e84)
        transferAllowance(35044)
\end{minted}
As shown by the fuzzer results, with the original code there is a path, then a call sequence such that the constraints required by the test, are not met. This is because the original code places no constraints on functions such as \mintinline{solidity}{marry(address sp)}, \texttt{setTaxAllowance} or \texttt{setSpouse}.

Basically, the \texttt{echidna\_transfer\_huge\_amount\_of\_allowance} test shows how it is possible to set an arbitrary value of \texttt{taxAllowance}, after which set a spouse (without going through marry) and after which do a transfer. From the original code this behavior is permissible, but since it is undesirable that is why the requirements with the constraints on marriage and reciprocity were inserted.The \texttt{echidna\_transfer\_allowance} test on the other hand shows how it is possible to do a marry on an address (in this case the fuzzer is using the address of \texttt{alpha}) and then transfer 1, also this behavior from the original code is permissible.This behavior is undesirable since before transferring the \texttt{taxAllowance} we must necessarily check the reciprocity constraint. If fuzzer marries with \texttt{alpha}, and transfers 1, then \texttt{alpha}'s allowance will always be greater than expected, even when \texttt{alpha} decides to join in marriage with \texttt{bravo}. 
To highlight the effectiveness of the inserted requirements, the result of the usual tests performed instead on Taxpayer.sol is shown below
\begin{minted}[label=results on Taxpayer.sol, labelposition=topline, frame=single]{bash}
echidna_transfer_allowance: passing
echidna_transfer_huge_amount_of_allowance: passing
\end{minted}

\section{People aged 65 and over have a higher tax allowance, of 7000}
To introduce this functionality within the code, it was necessary to modify the \mintinline{solidity}{haveBirthday()} function, granting an extra \texttt{ALLOWANCE\_OAP-DEFAULT\_ALLOWANCE} to the contract when it reaches an age of 65.
The choice was made to use increment by difference so as not to overwrite potential allowance changes. (In fact, it would otherwise have been possible to transfer all the allowance, getting to 0, and then at age 65 having 7000 again.)
\begin{minted}[linenos,breaklines, firstnumber=167,label=Taxpayer.sol, labelposition=topline, frame=single]{solidity}
function haveBirthday() public {
    age++;
    if (age == 65 && !getIsMarried()) 
        taxAllowance += (ALLOWANCE_OAP - DEFAULT_ALLOWANCE);
    else if (age == 65 && getIsMarried()) 
        this.setTaxAllowance(this.getTaxAllowance()+(ALLOWANCE_OAP - DEFAULT_ALLOWANCE));
}
\end{minted} 
The need to have to distinguish the state in which \texttt{isMarried} is derived from the fact that one of the assumptions of this report, is that certain functions can only be called in certain contexts. And among these is \mintinline{solidity}{setTaxAllowance(uint ta)}, which can only be called via \mintinline{solidity}{transferAllowance(uint change)}, which can by definition only be called if \mintinline{solidity}{isMarried=true}.

The choice to use the set method instead of direct assignment comes from wanting to further control the validity of operations.
Another useful requirement to ensure the required functionality is the one inserted in the \mintinline{solidity}{setTaxAllowance(uint ta)}, where the age of the couple is taken into account, ensuring that the sum of the two can be a maximum of \texttt{2*ALLOWANCE\_OAP} if both are over 65 years old, or \texttt{DEFAULT\_ALLOWANCE + ALLLOWANCE\_OAP} where the couple is of mixed age. (from line 118 of Taxpayer.sol)

Below are reported the tests.
\begin{minted}[breaklines, label=TaxpayerTesting.sol, labelposition=topline, frame=single]{solidity}
function echidna_allowance_older_than_sixtyfive_for_both() public returns bool) {
    be_old(bravo);
    be_old(alpha);
    alpha.transferAllowance(2000);
    return bravo.getTaxAllowance() + alpha.getTaxAllowance() == ALLOWANCE_OAP + ALLOWANCE_OAP;
}

function echidna_allowance_older_than_sixtyfive_for_only_one() public returns (bool) {
    be_old(bravo);
    alpha.transferAllowance(2000);
    return bravo.getTaxAllowance() + alpha.getTaxAllowance() == DEFAULT_ALLOWANCE + ALLOWANCE_OAP;
}
\end{minted} 
\begin{minted}[label=results on Taxpayer.sol, labelposition=topline, frame=single]{bash}
echidna_allowance_older_than_sixtyfive_for_only_one: passing
echidna_allowance_older_than_sixtyfive_for_both: passing
\end{minted}
\section{Extras}
\subsection{Every person has an income tax allowance on which no tax is paid}
From the provided code, it appears that the value of "income" is initially set to 0 and is not subsequently modified. This is also due to the absence of getter and setter methods. Below is a potential fix, primarily addressing the implementation of these two methods. It is important to note that, in order to secure the setter method, it must include constraints on the rule policy of those who can invoke the function. This is essential to prevent a contract from calling \texttt{setIncome} on itself by temporarily declaring a lower value and then subsequently declaring a higher one. To mitigate this, the use of Role-Based Access Control (RBAC)\footnote{Is a security model that restricts system access to authorized users based on their assigned roles and responsibilities, enhancing access management and reducing potential security risks.} policies is recommended.
\break
To implement this specification, assuming the existence of secure getter and setter methods, the code can be structured as follows:
\begin{minted}[breaklines]{solidity}
function getIncome() public view returns (uint256) {
    return income;
}

// Secure setter method with RBAC control (added onlyAdmin invariant)
function setIncome(uint256 _newIncome) public onlyAdmin {
    // useful require() to avoid unexpected behaviour
    income = _newIncome;
}

function isTaxableIncome(bool considerCouple) public returns (bool){
    if(considerCouple){
        require(getSpouse() != address(0) && getIsMarried(), "You have to be marry to use considerCouple flag");
        Taxpayer spouse = Taxpayer(address(getSpouse()));
        return getIncome() + spouse.getIncome() <= getTaxAllowance() + spouse.getTaxAllowance();
    }else {
        return getIncome() < getTaxAllowance();
    }
}

function getTaxableIncome(bool considerCouple) public returns (uint256){
    if(!isTaxableIncome(considerCouple)) return getIncome();
    if(considerCouple){
        Taxpayer spouse = Taxpayer(address(getSpouse()));
        return getIncome() - getTaxAllowance() - (spouse.getIncome() + spouse.getTaxAllowance());
    }
    else{
        return getIncome() - getTaxAllowance();
    }
}

\end{minted}
the \texttt{considerCouple} flag is used to allow the user to assess his income even if taxpooling has been done.In the case where \texttt{considerCouple = false}, then the person is considered to be a single individual, even if he is married (\textit{this could be detrimental at the time when a person has transferred all of his taxallowance and then wants to assess the taxability of his income, which will be 100 percent}). In the case where \texttt{considerCouple = true} then the two \texttt{taxAllowances} will be added together, subtracted from the spouse's income, and that value represents the new "taxAllowance" to be used to first assess whether the income is taxable, and if so, by how much.



\subsection{Style edits and warning removal}
In all files within the repository, the \texttt{slither-format}\footnote{\href{https://github.com/crytic/slither/wiki/Slither-format}{github.com/crytic/slither/wiki/Slither-format}} command was run, which provides a patch to align the code with what the guidelines are (example new\_spouse written in camelCase instead of snake\_case).

Two other warnings have been resolved, the first concerns the use of the `view` identifier for those functions that do not change state, typical of getter() methods.
\begin{minted}[linenos,breaklines, firstnumber=163, label=Taxpayer.sol,labelposition=topline, frame=single, escapeinside=||]{solidity}
function getTaxAllowance() public |\colorbox{lightgray}{view}| returns (uint256) {
    return taxAllowance;
}
\end{minted}
The last warning concerns the \texttt{SPDX-License-Identifier}\footnote{The code comment \texttt{// SPDX-License-Identifier:<license>} serves as a standardized declaration of the software's licensing terms, specifying that it is released under the certain License.}, set as a common practice under MIT License that permits users to use, modify, and distribute software freely, requiring only that the original license and copyright notice be included.

\subsection{Useful (getter) function}
Two get functions were added to improve the effectiveness on validation checks. These functions do not alter the state of the contract in fact they are defined with \mintinline{solidity}{view} identifier.
\begin{minted}[linenos,breaklines, firstnumber=179, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
function getAge() public view returns (uint256) {
    return age;
}

function getIsMarried() public view returns (bool) {
    return isMarried;
}
\end{minted}
\subsection{Requirements}
Some conditions have been added to make the code more "real," preventing undesirable behavior. The code provided does not require any of these changes, so they can be removed, but these provide robustness to the code and "logical" continuity.
\subsubsection{Can born only from addr(0x0) or married couple}
For example a constraint added require a contract needs to be created with 2 parents options.
\begin{itemize}
    \small
    \item You can have parent1 and 2 as address(0)
    \item You can have parent1 and 2 different than address(0) only if they are married each others.
\end{itemize}
The choice of second requirements isn't needed, of course in real life you can have a baby out of a marriage, but for this scenario we assume you cannot.
\begin{minted}[linenos,breaklines, firstnumber=19, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
constructor(address p1, address p2) {
    require(
        (p1 == address(0) && p2 == address(0)) ||
            (Taxpayer(p1).getSpouse() == p2 &&
                Taxpayer(p2).getSpouse() == p1),
        "A new born is allowed only form init and married couple"
    );
    age = 0;
    isMarried = false;
    parent1 = p1;
    parent2 = p2;
    spouse = (address(0));
    income = 0;
    tax_allowance = DEFAULT_ALLOWANCE;
}
\end{minted}
This improvement is validated by the following test which operates through the use of a \mintinline{solidity}{try{}catch{}} statement.
\begin{minted}[linenos,breaklines, firstnumber=87, label=TaxpayerTesting.sol,labelposition=topline, frame=single]{solidity}
function echidna_block_spawn_of_orphan() public returns (bool) {
    try new Taxpayer(address(1), address(2)) returns (Taxpayer) {
        return false;
    } catch {
        return true; // exception was raised
    }
}
\end{minted}
As you can read from the test, the code tries to create a contract with \mintinline{solidity}{address(1)} and \mintinline{solidity}{address(2)} as parent1 and parent2 respectively. But the expected result is that the test fails because of the require on line 21 of Taxpayer.sol. So we handle this event inside the catch\verb|{}| block.
Another test, more easy to read is shown below: (\textit{Notice: alpha and bravo are married from constructor})
\begin{minted}[linenos,breaklines, firstnumber=37, label=TaxpayerTesting.sol,labelposition=topline, frame=single]{solidity}
function echidna_couple_make_a_baby() public returns (bool) {
    try new Taxpayer(address(alpha), address(bravo)) {
        return true; // works successfully
    } catch {
        return false; // an exception was raised by contract
    }
}
\end{minted}
\subsubsection{setSpouse valid only for divorce purpose}
\label{sec:setspouse}
The code proposed below helps the understanding of \hyperref[sec:original_marry]{marry() function} explained above.
The one proposed is an assumption that was made to make the code fluid, namely that setSpouse can be called as from the original code, only via the \mintinline{solidity}{divorce()} function. Obviously from the original code no such constraint is present, but the decision to include it forces users not to be able to call a \mintinline{solidity}{setSpouse(address sp)} on themselves with a dummy or invalid address, thus avoiding unwanted behavior.
\begin{minted}[linenos,breaklines, firstnumber=100, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
function setSpouse(address sp) public {
    require(sp != address(this), "You cannot call setSpouse with yourself");
    require(
        (getSpouse() != address(0) && getIsMarried() && sp == address(0)),
        "You are already married, you can call this function only for divorce purpose now"
    );
    spouse = (address(sp));
}
\end{minted}
With the condition placed in the require, three conditions must be validated simultaneously "sp" as an input parameter must be equal to \mintinline{solidity}{addr(0)} the contract executing the \mintinline{solidity}{setSpouse(address sp)}  must be \mintinline{solidity}{isMarried=True} and then its \mintinline{solidity}{getSpouse()} must return an address other than \mintinline{solidity}{addr(0)}
\subsubsection{Solve tax pooling before divorce}

\begin{minted}[linenos,breaklines, firstnumber=70, label=Taxpayer.sol,labelposition=topline, frame=single]{solidity}
function divorce() public {
    require(
        getSpouse() != address(0) && getIsMarried(),
        "You're not already married"
    );
    Taxpayer sp = Taxpayer(address(spouse));
    require(
        sp.getSpouse() == address(this) && sp.getIsMarried(),
        "That person isn't married with you"
    );
    require(
        (getTaxAllowance() == DEFAULT_ALLOWANCE && age < 65) ||
            ((getTaxAllowance() == ALLOWANCE_OAP && age >= 65) &&
                (sp.getTaxAllowance() == DEFAULT_ALLOWANCE && sp.getAge() < 65)) ||
            (sp.getTaxAllowance() == ALLOWANCE_OAP && sp.getAge() >= 65),
        "Before divorcing, fix your tax pool allowance"
    ); 
    /**
        if(getAge()>=65) {setTaxAllowance(ALLOWANCE_OAP);}
        else {setTaxAllowance(DEFAULT_ALLOWANCE);}
     */
    sp.setSpouse(address(0));
    spouse = address(0);
    /*
    sp.divorce(); // instead of sp.setSpouse(address(0));
    */
    isMarried = false;
}
\end{minted}
In real life scenario if we have previously taxpooled with the partner and then decide to get divorced, everyone has to take back what they are fiscally entitled to, without being able to access any deductions. That is why a special requirement has been included. The method for bypassing the require has also been written if it is deemed unnecessary and indeed wasteful in terms of transactions (\textit{See annotated code on lines 88 - 89.})

From the snippet shown above another interesting detail also emerges, that the way the code has been provided if Alpha after being married to Bravo, performs a \mintinline{solidity}{divorce()} its \texttt{isMarried} status changes to False, while Bravo's remains at True. The way the various \texttt{require()} were implemented this does not turn out to be a problem since the checks were done based on the \mintinline{solidity}{getSpouse()}, but for better performance, as well as for the \mintinline{solidity}{marry(address newSpouse)} which could be modified to alter the state of both contracts, the same can be done for the divorce by uncommenting the line 94
\subsubsection{Ensure to be married before divorce}
As can be seen from the requirement of line 71 of Taxpayer.sol, within the \texttt{divorce()} method, the clause that the divorce caller must necessarily be married has been inserted, and the reciprocity constraint has also been added, i.e., that the person set as the spouse is actually married to the divorce caller (line 76)
\subsection{Echidna through CI/CD pipeline}
Within the DevSecOps\footnote{DevSecOps (Development Security Operations)  is a collaborative approach that integrates security practices throughout the entire software development process.} framework, where security is integrated from the early stages of the development cycle\footnote{The development cycle refers to the iterative process of software development, encompassing stages such as planning, coding, testing, and deployment.}, incorporating Echidna into the CI/CD\footnote{CI/CD (Continuous Integration/Continuous Deployment) is a software development practice that involves continuous integration of code changes, automated testing, and seamless deployment to production, ensuring a streamlined and efficient development pipeline.} pipeline allows for continuous assessment of contract security. This significantly reduces the risks associated with security vulnerabilities, as issues are detected and addressed before the code reaches the production environment.

To ensure effective implementation of Echidna within the CI/CD pipeline, it has been integrated with GitHub Actions\footnote{GitHub Actions are automated workflows within the GitHub platform that allow developers to define, customize, and automate software development workflows.}. This ensures that every code change undergoes automatic analysis by Echidna before release, ensuring that the released code is always secure and free from vulnerabilities. This practice provides an additional assurance of code consistency and integrity, contributing to maintaining a secure and reliable development and release environment.
The page containing the complete history of triggered GitHub Action implemented\footnote{\href{https://github.com/Owanesh/SSA2324/blob/main/.github/workflows/main.yml}{github.com/Owanesh/SSA2324/blob/main/.github/workflows/main.yml}} is available on GitHub under the [\href{https://github.com/Owanesh/SSA2324/actions}{Actions}] section of the repository .
\end{document}
